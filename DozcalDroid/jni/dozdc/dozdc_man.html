   <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>dozdc(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
dozdc - arbitrary precision dozenal calculator 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>dozdc [-ezdr]
[-k </b> <i>precision</i> <b>] [</b> <i>equation</i> <b>]</b> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>dozdc</b> An arbitrary-precision Reverse
Polish Notation (RPN, postfix notation) calculator which works in dozenal
(base-12).  All normal arithmetic functions, plus trigonometry, some basic
constants (pi, euler, phi), logarithms, and other functions. Supports variables
of arbitrary user-defined names. 
<p> There is also a graphical version, gdozdc,
written in Perl/Tk.  Obviously, this requires a working version of Perl
and the Tk libraries.  gdozdc is pretty self-explanatory; its differences
are described below. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<dl>

<dt>-z</dt>
<dd>Indicates that those functions which take angles
as arguments (trigonometric functions in particular) will take them in
zeniPis, the TGM unit.  This is the default. </dd>

<dt>-r</dt>
<dd>Indicates that those functions
which take angles as arguments (trigonometric functions in particular)
will take them in radians. </dd>

<dt>-d</dt>
<dd>Indicates that those functions which take angles
as arguments (trigonometric functions in particular) will take them in
degrees. </dd>

<dt>-e</dt>
<dd>Write the output in exponential notation. </dd>

<dt>-k precision</dt>
<dd>Print the
resulting output with  <i>precision</i> digits of precision.  By default, the output
is printed with four digits after the zenimal point.  If there is no fractional
part, no zenimal point or fractional digits will be printed, even if this
option is specified.  If the precision is too high, a message will be printed
noting this, and the precision will be reduced to the system&rsquo;s maximum. </dd>

<dt>equation</dt>
<dd>If
present, must be the final argument at the command line. Processes the equation,
prints the answer, and exits.  Must be entered within quotation marks so
that it&rsquo;s considered a single argument by the program. </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Equation Syntax</a></h2>
The
syntax of an equation is fairly standard Reverse Polish Notation (also
called postfix notation or simply RPN). Each operator has either two arguments
(these are called "binary" operators) or one (these are called "unary"
operators).  Operators (like "+" or "cos") come  <i>after</i> their arguments (that
is, the numbers or variables they work on).  So, for example, rather than
writing "1 + 1", one writes "1 1 +"; rather than writing cos(30), one writes
"30 cos".  This has the benefit of being unambiguous (no parentheses are
necessary). 
<h2><a name='sect5' href='#toc5'>Operators</a></h2>

<dl>

<dt>=</dt>
<dd>Pops and prints the top of the stack; in other words,
gives you your answer.  The operations you request will be done after hitting
"enter"; however, no answer will be printed unless you put in an "=" and
hit that.  This allows long calculations to be split between lines without
having intermediate results, which may not be interesting, printed unless
you want them to be. </dd>

<dt>+, -, *, /</dt>
<dd>The basic arithmetic operators; they are all
binary.  They work precisely as one would expect them to.  "-" and "/" must
have their arguments in the right order; however, this is the same as the
order one would expect.  "x - y" is "x y -"; "x / y" is "x y /".  So this shouldn&rsquo;t
trip anyone up. Of course, one cannot divide by zero; trying will emit an
error message, and the numbers will be pushed back onto the stack, as they
were before the attempt. </dd>

<dt>%</dt>
<dd>The modulus operator, or "mod".  Internally this
is fmod(); as such, it works on floating-point numbers as well as integers.
 Like "/", one cannot divide by zero; trying will emit an error message,
and the numbers will be pushed back onto the stack, as they were before
the attempt. </dd>

<dt>k</dt>
<dd>Precision; this is a unary operator.  As such, its argument
comes prior to it.  It pops the last number and makes that value the new
precision.  Obviously, fractional precisions are meaningless, and will be
truncated to a whole number. Enter like so:  "8 k" will ask that answers
be printed to eight zenimal places.  If the value is too large, then, as
with the command-line option, it will simply be reduced to the largest possible
on your machine. </dd>

<dt>sin, cos, tan</dt>
<dd>Trigonometric functions that we&rsquo;re all familiar
with.  These are unary operators, so they take the number entered immediately
before them as their argument.  By default, they operate on zeniPis; this
can be changed.  See the command "rad" and the command-line option "r", as
well as "d" and the command-line option "d". </dd>

<dt>asin, acos, atan</dt>
<dd>Inverse trigonometric
functions.  Unary; used like the normal trigonometric functions.  Naturally,
these must be in the range of -1 to 1 (except for atan, which can take any
real number); if they are fed a different value, they politely cough it
back onto the stack and let the user know. They emit values in radians or
degrees, depending on the current angle setting. </dd>

<dt>sinh, cosh, tanh</dt>
<dd>Hyperbolic
trigonometric functions.  Unary; used like the normal and inverse ones. </dd>

<dt>z</dt>
<dd>Makes
those functions which work on angles use zeniPis rather than degrees or
radians.  This is the default.  See the command-line option "z". </dd>

<dt>d</dt>
<dd>Makes those
functions which work on angles use degrees rather than zeniPis or radians.
 See the command-line option "d". </dd>

<dt>rad</dt>
<dd>Makes those functions which work on
angles use radians rather than zeniPis or degrees.  See the command-line
option "r". </dd>

<dt>^</dt>
<dd>A binary operator; it raises its first argument to the power
of its second argument.  So "2 3 ^" has a result of 8; it means "2 raised
to the power of 3".  This can also be used to fake roots greater than two;
"8 1 3 / ^" raises 8 to the power of 1/3, which gives the cube root of 8.
</dd>

<dt>v</dt>
<dd>A unary operator; it takes the square root of its single argument.  So
"41 v" will yield 7.  Of course, one cannot take the square root of a negative
number; trying will emit an error message, and the attempted argument will
be pushed back onto the stack unchanged. </dd>

<dt>log</dt>
<dd>A unary operator; gives the
dozenal logarithm of its single argument. </dd>

<dt>logx</dt>
<dd>A unary operator; gives the
base-ten logarithm of its single argument.  It&rsquo;s worth noting that this computes
the base-ten logarithm of a <i>dozenal</i> number and emits it as a  <i>dozenal</i> result.
 This fact has tripped up the author of the program a few times when it
didn&rsquo;t match up to a base-ten logarithm from another calculator.  Trust the
result; make sure you&rsquo;re entering the same number and converting the result
to decimal.  It&rsquo;s correct. </dd>

<dt>ln</dt>
<dd>A unary operator; gives the natural logarithm
(the base is the euler number) of its single argument. </dd>

<dt>dlg</dt>
<dd>Pendlebury&rsquo;s dublogs;
these are logarithms with a base of two.  dozdc can handle only  <i>straight</i>
dublogs, not the  <i>mixed</i> dublogs, which are useful for some applications
but much harder to handle automatically. </dd>

<dt>logb</dt>
<dd>A binary operator; permits
computation of logs in an arbitrary base.  Its first argument is the number
the log of which is sought; its second is the base of that log.  So, for
example, "45 log" is equivalent to "45 10 logb"; "45 logx" is equivalent
to "45 X logb"; and "45 ln" is equivalent to "45 eul logb". </dd>

<dt>!</dt>
<dd>A unary operator;
takes the factorial of its single argument.  "5 !" yield "X0".  If a non-integer
is given, it will simply truncate thre fractional part and calculate the
factorial of the integer value. </dd>

<dt>exp</dt>
<dd>A unary operator; gives the euler number
raised to the power of its single argument.  So "2 exp" is equivalent to
"eul 2 ^". </dd>

<dt>ldexp</dt>
<dd>A binary operator; it raises 2 to the power of its second
argument, then multiplies it by its first.  So, for example, "10 2 ldexp"
will result in 40; 2^2 is 4, 10 * 4 is 40. </dd>

<dt>abs</dt>
<dd>A unary operator; gives the
absolute value of its single argument.  (That is, it&rsquo;s positive, it leaves
it as is; if it&rsquo;s negative, it makes it positive.) </dd>

<dt>recip</dt>
<dd>A unary operator;
gives the reciprocal of its single argument (that is, one divided by that
argument). </dd>
</dl>

<h2><a name='sect6' href='#toc6'>Constants</a></h2>
dozdc provides a number of constants.  These are the
classic "transcendental" numbers, or at least a few of them.  Of course,
they are emitted in dozenal.  The "=" syntax is helpful here; to learn the
dozenal value of pi, for example, one need simply tell dozdc "pi =", and
pi, the value at the top of the stack, will be printed. 
<dl>

<dt>pi</dt>
<dd>Takes no arguments;
simply contains the value of pi. </dd>

<dt>eul</dt>
<dd>Takes no arguments; simply contains
the value of the euler constant. </dd>

<dt>phi</dt>
<dd>Takes no arguments; simply contains
the value of phi, the "Golden Ratio." </dd>
</dl>

<h2><a name='sect7' href='#toc7'>Variables</a></h2>
dozdc has basic variable
handling; it is basic, but it&rsquo;s powerful enough for many uses.  The program
allows for up to fifty separate variables, each of which can be arbitrarily
named.  These names can be up to thirty characters long; longer and they
will be silently truncated by the program. The names must begin with a dollar
sign (&rsquo;$&rsquo;), after the manner of Perl or bash. 
<p> The first time a variable name
appears, the last value on the stack is popped off the stack and assigned
to it; ever after, when the variable name appears it pushes that value
back onto the stack.  The variable cannot be assigned a new value. 
<p> So, for
example, a typical usage scenario might be such: 
<p> <b>1 3 / $result ($result
== 1/3, or 0;4)</b> 
<p> <b>8 $result ^ = (prints 8 ^ 0;4, the cube root of 8,</b> which
is 2)" 
<p> They really are that simple. 
<h2><a name='sect8' href='#toc8'>Comments</a></h2>
Comments are available, and
are useful in particularly long or complex files that will be handed to
dozdc for computation.  Because dozdc works by words, not be lines, comments
are word-based.  Fortunately, the words can be as long as one wants.  It&rsquo;s
important, however, to make sure that the comments contain no spaces, tabs,
or newlines, or dozdc will misinterpret the text after the first one such
as a command or number it needs to deal with. 
<p> Comments are all proceeded
with the &rsquo;#&rsquo; character, and include all characters following it in the same
word.  So, in our above variable example, we might do the following: 
<p> <b>1
3 / $result</b> 
<p> <b>#_gives_us_exponent_for_cube_roots</b> 
<p> <b>8 $result ^ = </b> 
<p> This will
accomplish the same thing, but make it clear what "$result" is doing explicitly.
 (Of course, one could just name the variable "$cuberoot" or something
similar, but we&rsquo;re doing examples here.) 
<p> One should be aware that blank
lines in the input files will mess up the results, because of the way dozdc
deals with words.  However, inserting a comment (a line consisting solely
of &rsquo;#&rsquo;) rather than a blank line will preserve a correct result while still
allowing the helpful whitespace. 
<h2><a name='sect9' href='#toc9'>Other Commands</a></h2>

<dl>

<dt>quit</dt>
<dd>Quits the program.  &rsquo;Nuff
said. </dd>
</dl>

<h2><a name='sect10' href='#toc10'>GRAPHICAL VERSION, gdozdc</a></h2>
gdozdc is the graphical version of dozdc,
and it differs in some significant points.  Specifically, it&rsquo;s  <i>infix,</i> not
postfix; that means that you enter your equations in the same way you learned
to write them down in school, with your binary operators (the ones that
take two arguments, like the basic arithmetic functions) in between their
two arguments.  E.g., you write "4 + 5", rather than dozdc&rsquo;s "4 5 +". 
<p> This
system is not particularly extensible; that is, it only works with binary
operators, and it&rsquo;s inherently ambiguous. gdozdc therefore offers the usual
infix disambiguation operators, parentheses, which can be used to group
operations however might be necessary.  This applies to *all* binary operators,
even ones where this behavior might be surprising; e.g., for arbitrary base
logarithms, one inputs the base, "logb", then the number; so for the logarithm
of three to base two, one writes "2 logb 3". 
<p> Non-binary operations work
as they do in dozdc; that is, they are postfix.  This is typical even for
modern infix calculators.  For example, one writes "5 !" for factorial five,
and "0;6 sin" for the sine of 0;6. 
<p> gdozdc also implements some memory functions.
 "CM" means to clear memory; "M" means to save the current field to memory
(this is the whole field, not the result of the operations contained in
it); "M+" means to replace the current field with the contents of the memory;
and "M++" means to append the contents of the memory to the current field.

<p> Hovering over a button will give the keyboard shortcut in a small popup
balloon, as well as list it and a brief explanation in the lower bar. 
<h2><a name='sect11' href='#toc11'>Bugs</a></h2>
None
known at this time. 
<h2><a name='sect12' href='#toc12'>Author</a></h2>
Donald P. Goodman III &lt;dgoodmaniii at gmail dot
com&gt; 
<h2><a name='sect13' href='#toc13'>See Also</a></h2>
<a href='dec.1'><b>dec</b>(1)</a>
, <a href='dozdc.1'><b>dozdc</b>(1)</a>
, <a href='tgmconv.1'><b>tgmconv</b>(1)</a>
, <a href='dozdate.1'><b>dozdate</b>(1)</a>
, <a href='dozword.1'><b>dozword</b>(1)</a>
, <a href='dozpret.1'><b>dozpret</b>(1)</a>

<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Equation Syntax</a></li>
<li><a name='toc5' href='#sect5'>Operators</a></li>
<li><a name='toc6' href='#sect6'>Constants</a></li>
<li><a name='toc7' href='#sect7'>Variables</a></li>
<li><a name='toc8' href='#sect8'>Comments</a></li>
<li><a name='toc9' href='#sect9'>Other Commands</a></li>
<li><a name='toc10' href='#sect10'>GRAPHICAL VERSION, gdozdc</a></li>
<li><a name='toc11' href='#sect11'>Bugs</a></li>
<li><a name='toc12' href='#sect12'>Author</a></li>
<li><a name='toc13' href='#sect13'>See Also</a></li>
</ul>
</body>
</html>
